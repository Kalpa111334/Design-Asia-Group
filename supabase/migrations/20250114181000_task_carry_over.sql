-- Carry over incomplete (non-completed/non-cancelled) tasks to the next calendar day
-- Creates a small log table to ensure we only run once per calendar day

create table if not exists public.task_maintenance_log (
  id bigint generated by default as identity primary key,
  job_name text not null,
  run_date date not null,
  details jsonb,
  created_at timestamptz not null default now(),
  unique (job_name, run_date)
);

comment on table public.task_maintenance_log is 'Tracks daily maintenance runs to avoid duplicate executions';

-- Function returns number of tasks updated
create or replace function public.carry_over_incomplete_tasks()
returns table(updated_count integer)
language plpgsql
security definer
set search_path = public, extensions
as $$
declare
  today date := current_date;
  already_ran boolean;
  v_updated integer := 0;
begin
  -- Ensure it runs only once per day
  select exists (
    select 1 from public.task_maintenance_log
    where job_name = 'carry_over_incomplete_tasks' and run_date = today
  ) into already_ran;

  if already_ran then
    return query select 0::integer as updated_count; -- no-op
  end if;

  -- Carry over rule: any task not in ('completed','cancelled','rejected') with due_date < today
  -- gets its due_date set to today (next working day approach can be added later)
  update public.tasks t
  set due_date = today
  where coalesce(t.status, 'pending') not in ('completed','cancelled','rejected')
    and t.due_date is not null
    and t.due_date::date < today;

  get diagnostics v_updated = row_count;

  insert into public.task_maintenance_log (job_name, run_date, details)
  values ('carry_over_incomplete_tasks', today, jsonb_build_object('updated', v_updated));

  return query select v_updated as updated_count;
end;
$$;

revoke all on function public.carry_over_incomplete_tasks from public;
grant execute on function public.carry_over_incomplete_tasks to authenticated, service_role;


